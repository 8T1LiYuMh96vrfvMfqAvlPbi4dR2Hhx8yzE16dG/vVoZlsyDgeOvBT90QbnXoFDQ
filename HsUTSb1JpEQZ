-- Functions

local Setup, Called = {}, {};
print("Loaded4")
Setup["Basics"] = function(self)
    if Called["Basics"] then return; end;
    Called["Basics"] = true; 

    Players = game:GetService("Players");
    ReplicatedStorage = game:GetService("ReplicatedStorage"); Replicated = ReplicatedStorage;
    TweenService = game:GetService("TweenService"); TS = TweenService;
    UserInputService = game:GetService("UserInputService"); UIS = UserInputService;
    RunService = game:GetService("RunService"); RSV = RunService; rsv = RunService;
    CoreGui = game:GetService("CoreGui");
    HttpService = game:GetService("HttpService");

    Client = Players.LocalPlayer; client = Client; LocalPlayer = Client; LP = Client;
    Camera = workspace.CurrentCamera; CC = Camera; cc = Camera;
    Mouse = LP:GetMouse(); mouse = Mouse;

    PlayerGui = LP:WaitForChild("PlayerGui");
    Backpack = LP:WaitForChild("Backpack");

    task.spawn(function()
        Character = LP.Character or LP.CharacterAdded:Wait(); Char = Character; char = Character;
        Humanoid = Char:WaitForChild("Humanoid"); Hum = Humanoid; hum = Humanoid;
        HumanoidRootPart = Char:WaitForChild("HumanoidRootPart") or Char.PrimaryPart; HRP = HumanoidRootPart; hrp =
            HumanoidRootPart;

        LP.CharacterAdded:Connect(function()
            Character = LP.Character; Char = Character; char = Character;
            Humanoid = Char:WaitForChild("Humanoid"); Hum = Humanoid; hum = Humanoid;
            HumanoidRootPart = Char:WaitForChild("HumanoidRootPart") or Char.PrimaryPart; HRP = HumanoidRootPart; hrp =
                HumanoidRootPart;
        end);
    end);
end;

Setup["ClientController"] = function(self)
    local Manager = {};
    if Called["ClientController"] then return Called["ClientController"]; end;
    Called["ClientController"] = Manager;

    self:Basics();

    function Manager:Reset()
        if replicatesignal then
            replicatesignal(Client.Kill);
        elseif Humanoid then
            Humanoid:ChangeState(Enum.HumanoidStateType.Dead);
        elseif Character then
            Character:BreakJoints();
        end;
    end;

    local Start, Last;
    function Manager:NoFall()
        task.spawn(function()
            Last = os.clock();
            if not Start then
                Start = os.clock();
                local NoFall = Instance.new("BodyVelocity");
                NoFall.MaxForce = vector.create(math.huge, math.huge, math.huge);
                NoFall.Velocity = vector.zero;
                NoFall.Parent = HRP;
    
                while Character and Character.Parent and os.clock()-Last<=1 do
                    task.wait();
                end;
    
                NoFall:Destroy();
                Start=nil;
            end;
        end);
    end;

    function Manager:Goto(cf)
        if typeof(cf) == 'Vector3' then cf = CFrame.new(cf) end;
        if typeof(cf) ~= 'CFrame' then return; end;

        if hrp then
            hrp.CFrame = cf;
        end;
    end;

    local Recorder = self:InputRecorder();
    local walkspeed, jumppower;
    Manager['Movement'] = {
        -- TP Walk
        TWX = nil,

        WS = function(Speed)
            walkspeed = Speed;
        end,

        TW = function(self, Toggle)
            if self.TWX then
                self.TWX:Disconnect();
            end;

            if Toggle then
                self.TWX = rsv.RenderStepped:Connect(function()
                    if hum.MoveDirection.Magnitude > 0 then
                        walkspeed = walkspeed or 1;
                        char:TranslateBy(hum.MoveDirection * walkspeed)
                    end;
                end);
            end;
        end,

        -- Jump
        IJX = nil,
        IJX2 = nil,

        JP = function(Power)
            jumppower = Power;
        end,

        IJ = function(self, Toggle)
            if self.IJX then
                self.IJX:Disconnect();
                self.IJX2:Disconnect();
            end;

            if Toggle then
                local Pressing = false;

                local function jump()
                    local Power = jumppower or hum.JumpPower or 50;
                    hrp.Velocity = Vector3.new(hrp.Velocity.X, Power, hrp.Velocity.Z);
                end;

                local function on()
                    Pressing = true;

                    while Pressing do
                        jump();
                        task.wait(.1);
                    end;
                end;

                local function off()
                    Pressing = false;
                end;

                self.IJX = Recorder:Bind("Space", on);
                self.IJX = Recorder:Bind("Space", off, true);
            end;
        end,
    };

    return Manager;
end;

Setup["HttpService"] = function(self)
    local Manager = {};
    if Called["HttpService"] then return Called["HttpService"]; end;
    Called["HttpService"] = Manager;

    self:Basics();

    function Manager:Webhook(weblink, title, fields)
        if not weblink then return; end;
        local data = {
            ["embeds"] = {
                {
                    ["title"] = title or "",
                    ["type"] = "rich",
                    ["color"] = tonumber(0x8383AA),
                    ["fields"] = fields
                },
            },
        };

        local newdata = HttpService:JSONEncode(data)

        request = http_request or request or HttpPost or syn.request;
        request({ Url = weblink, Body = newdata, Method = "POST", Headers = { ["content-type"] = "application/json" } });
    end;

    return Manager;
end;

Setup["File"] = function(self)
    local Manager, Allowed = {};
    if Called["File"] then return Called["File"]; end;
    Called["File"] = Manager;

    self:Basics();


    if readfile and writefile and isfolder and isfile and makefolder and delfolder then
        Allowed = true;
    end;

    function Manager:Read(path)
        if not Allowed then return; end;
        if typeof(path) ~= "string" then return; end;
        local contents;

        if isfile(path) then
            contents = readfile(path);
        elseif isfolder(path) then
            if listfiles then
                contents = listfiles(path);
            end;
        end;

        return contents;
    end;

    function Manager:Write(path, contents)
        if not Allowed then return; end;
        if typeof(path) ~= 'string' then return; end;

        local contents = contents or "";

        writefile(path, tostring(contents));
    end;

    function Manager:CreateFolder(path)
        if not Allowed then return; end;
        if typeof(path) ~= 'string' then return; end;

        if not isfolder(path) then
            makefolder(path);
        end;
    end;

    function Manager:DeleteFolder(path)
        if not Allowed then return; end;
        if typeof(path) ~= 'string' then return; end;
        if isfolder(path) then
            delfolder(path);
        end;
    end;

    function Manager:Execute(path)
        if not Allowed then return; end;
        if typeof(path) ~= 'string' then return; end;

        if isfile(path) then
            if runfile then
                runfile(path);
            else
                loadstring(readfile(path));
            end
        end;
    end;

    return Manager;
end;

Setup["Tween"] = function(self)
    local Manager, Storage = {}, {};
    if Called["Tween"] then return Called["Tween"]; end;
    Called["Tween"] = Manager;

    local Controller = Setup:ClientController();
    self:Basics();

    function Manager:Create(Data)
        task.spawn(function()
            if not Data then return; end;
            if Storage["Active"] then
                local Active = Storage["Active"];
                local isClose = Active.isClose();
                if Data["Extra"] then
                    Data.Extra(isClose);
                end;

                local OldData = Active.Data;
                if OldData.Position == OldData.Position then
                    Active.ChangeSpeed(Data.Speed);
                    return isClose;
                else
                    Active:Cancel();
                end;
            end;

                    
            local Target, Temporary = Data.Position, nil;
            local CF;
            if not Target then return; end;
            if typeof(Target) == "CFrame" then
                CF = Target;
                Target = Target.Position;
            end;
            
            local Speed = Data.Speed or {24, 24}; -- or {X, Y} 
            if typeof(Speed) ~= "table" then
                Speed = {Speed, Speed};
            end;

            local Surf = Data.Surf or false;

            local function Move(dt)
                local p1 = HRP.Position
                local p2 = Temporary or Target

                -- Base speeds (studs/sec)
                local baseXSpeed, baseYSpeed = table.unpack(Speed)

                -- Per-frame movement speeds
                local stepXSpeed = baseXSpeed * dt
                local stepYSpeed = baseYSpeed * dt

                -- Horizontal / vertical separation
                local xDiff = Vector3.new(p2.X - p1.X, 0, p2.Z - p1.Z)
                local yDiff = Vector3.new(0, p2.Y - p1.Y, 0)

                local xDis = xDiff.Magnitude
                local yDis = yDiff.Magnitude

                stepXSpeed = math.min(stepXSpeed, xDis)
                stepYSpeed = math.min(stepYSpeed, yDis)

                local txDiff = Vector3.new(Target.X - p1.X, 0, Target.Z - p1.Z)
                local xDir = txDiff.Magnitude > 0 and txDiff.Unit or Vector3.zero
                local yDir = yDis > 0 and yDiff.Unit or Vector3.zero

                -- Snap to target if close enough
                if xDis <= math.max(stepXSpeed, 1) and yDis <= math.max(stepYSpeed, 1) then
                    if p2 == Target then
                        HRP.CFrame = CF or CFrame.new(p2);

                        Storage["Active"]:Cancel()
                        if Data["Extra"] then
                            Data.Extra(true);
                        end;

                        return true;
                    else
                        HRP.CFrame = CFrame.new(p2)
                        Temporary = nil
                    end
                end

                if Surf and xDis > stepXSpeed then
                    local Params = RaycastParams.new()
                    Params.FilterDescendantsInstances = { Character }
                    Params.FilterType = Enum.RaycastFilterType.Blacklist
                    Params.IgnoreWater = true

                    -- Use BASE speed for lookahead
                    local Infront = workspace:Raycast(
                        p1 - vector.create(0, HRP.Size.Y/2, 0),
                        xDir * math.max(stepXSpeed, 4),
                        Params
                    )

                    if Infront then
                        local Part = Infront.Instance
                        local Top = Part.Position.Y + Part.Size.Y / 2
                        local TopDis = (math.abs(Top) - math.abs(p1.Y))
                        if TopDis < math.max(stepYSpeed, 1) then
                            HRP.CFrame = CFrame.new(p1.X, Top+1, p1.Z);
                        else
                            Temporary = Vector3.new(Infront.Position.X, Top+1, Infront.Position.Z) - xDir * 2;
                        end;
                    else
                        local Under = workspace:Raycast(
                            p1,
                            Vector3.new(0, -100, 0),
                            Params
                        )

                        if Under then
                            HRP.CFrame = CFrame.new(Under.Position + Vector3.new(0, 1, 0));
                        end
                    end
                end

                -- Recalculate after possible snapping
                p1 = HRP.Position

                xDiff = Vector3.new(p2.X - p1.X, 0, p2.Z - p1.Z)
                yDiff = Vector3.new(0, p2.Y - p1.Y, 0)

                xDis = xDiff.Magnitude
                yDis = yDiff.Magnitude

                xDir = xDis > 0 and xDiff.Unit or Vector3.zero
                yDir = yDis > 0 and yDiff.Unit or Vector3.zero

                -- Final translation
                local Translation

                if Surf and xDis > math.max(stepXSpeed, 1) then
                    -- Surfing: horizontal only
                    Translation = xDir * math.min(stepXSpeed, xDis)
                else
                    Translation =
                        xDir * math.min(stepXSpeed, xDis) +
                        yDir * math.min(stepYSpeed, yDis)
                end

                Controller:NoFall()
                HRP.CFrame += Translation
            end


            Storage["Active"] = { 
                Connection = RSV.Heartbeat:Connect(Move);

                Cancel=function(self) 
                    self.Connection:Disconnect(); 
                    Storage["Active"]=nil 
                end; 

                ChangeSpeed=function(New)  
                    if not New then return; end;

                    Speed = New;
                    if typeof(Speed) ~= "table" then
                        Speed = {Speed, Speed};
                    end;
                end; 

                isClose=function()
                    local p1 = HRP.Position;

                    local xSpeed, ySpeed = table.unpack(Speed);
                    local xDiff = Vector3.new(Target.X - p1.X, 0, Target.Z - p1.Z);
                    local yDiff = Vector3.new(0, Target.Y - p1.Y, 0);

                    local xDis = xDiff.Magnitude;
                    local yDis = yDiff.Magnitude;
                    
                    return xDis <= xSpeed/60 and yDis <= ySpeed/60;
                end;
            
                Data=Data
            };
        end);

        if Storage["Active"] then
            return Storage["Active"].isClose();
        end;
    end;

    function Manager:GetActive()
        return Storage["Active"];
    end;

    return Manager;
end;

Setup["VirtualInputManager"] = function(self)
    local Manager, VIM = {}, Instance.new("VirtualInputManager");
    if Called["VirtualInputManager"] then return Called["VirtualInputManager"]; end;
    Called["VirtualInputManager"] = Manager;

    function Manager:Press(Key)
        if typeof(Key) == 'string' then
            local EnumKey;

            pcall(function() EnumKey = Enum.KeyCode[Key] end);

            if not EnumKey then return; end;

            VIM:SendKeyEvent(true, EnumKey, false, game);
            task.wait()
            VIM:SendKeyEvent(false, EnumKey, false, game);
        end;
    end;

    function Manager:Click(mb)
        if typeof(MB) == 'number' then
            mb = math.clamp(mb, 0, 2);

            VIM:SendMouseButtonEvent(0, 0, mb, true, game);
            task.wait();
            VIM:SendMouseButtonEvent(0, 0, mb, false, game);
        end;
    end;

    function Manager:Hold(Key)
        if typeof(Key) == 'string' then
            local EnumKey;
            pcall(function() EnumKey = Enum.KeyCode[Key] end);
            if not EnumKey then return; end;

            VIM:SendKeyEvent(true, EnumKey, false, game);
        end;
    end;

    function Manager:Release(Key)
        if typeof(Key) == 'string' then
            local EnumKey;
            pcall(function() EnumKey = Enum.KeyCode[Key] end);
            if not EnumKey then return; end;

            VIM:SendKeyEvent(false, EnumKey, false, game);
        end;
    end;

    function Manager:Move(x, y)
        if (not x) or (not y) then return; end;
        VIM:SendMouseMoveEvent(x, y, game)
    end;

    return Manager;
end;

Setup["InputRecorder"] = function(self)
    local Manager = {};
    if Called["InputRecorder"] then return Called["InputRecorder"]; end;
    Called["InputRecorder"] = Manager;

    self:Basics();

    Manager.Pressed = {};
    function Manager:Record(OnUP, Settings)
        if not Settings then return; end;
        local Callback = Settings['Callback'];
        local Valid = Settings['Inputs'];
        local Type = Settings['Type'];
        local Break = Settings['Break'];
        local CancelKeys = Settings['CancelKeys'] or { "Escape", "Backspace" };
        local IgnoreProc = Settings['IgnoreProc'];
        local Recorder;

        if not Callback then return; end;

        local function OnResponse(Input, isTyping)
            if (not Input) or (isTyping and not IgnoreProc) then return; end;

            local Keycode = Input['KeyCode'];
            local UserInputType = Input['UserInputType'];
            if not Keycode then return; end;
            local KeyName = Keycode.Name;

            if KeyName == "Unknown" then
                if Type == "KeyCode" then return; end;

                KeyName = UserInputType.Name;
            end;

            if table.find(CancelKeys, KeyName) then
                if Recorder then
                    Recorder:Disconnect();
                    Callback();
                    return;
                end;
            end;

            if Valid then
                if table.find(Valid, KeyName) then
                    Callback(KeyName);
                else
                    for i, v in next, (Valid) do
                        if string.lower(v) == string.lower(KeyName) then
                            Callback(KeyName);
                        end;
                    end;
                end;
            else
                Callback(KeyName);
            end;

            if Break and Recorder then
                Recorder:Disconnect();
            end;
        end;

        if OnUP then
            Recorder = UserInputService.InputEnded:Connect(OnResponse);
        else
            Recorder = UserInputService.InputBegan:Connect(OnResponse);
        end;

        return Recorder;
    end;

    function Manager:Bind(Key, Callback, OnUP, IgnoreProc)
        if (not Key) or (not Callback) then return; end;

        return Manager:Record(OnUP, {
            Inputs = (typeof(Key) == "table" and Key) or { Key },
            CancelKeys = {},
            IgnoreProc = IgnoreProc,

            Callback = Callback,
        });
    end;

    UserInputService.InputBegan:Connect(function(Input, proc)
        if not proc then
            local Keycode = Input['KeyCode'];
            local UserInputType = Input['UserInputType'];
            if not Keycode then return; end;
            local KeyName = Keycode.Name;

            if KeyName == "Unknown" then
                if Type == "KeyCode" then return; end;

                KeyName = UserInputType.Name;
            end;
        end;
    end);

    UserInputService.InputEnded:Connect(function(Input, proc)
        if not proc then
            local Keycode = Input['KeyCode'];
            local UserInputType = Input['UserInputType'];
            if not Keycode then return; end;
            local KeyName = Keycode.Name;

            if KeyName == "Unknown" then
                if Type == "KeyCode" then return; end;

                KeyName = UserInputType.Name;
            end;
        end;
    end);

    return Manager;
end;

return Setup;
