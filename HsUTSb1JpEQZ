-- Functions

local Setup, Called = {}, {};
print("Loaded4")
Setup["Basics"] = function(self)
    if Called["Basics"] then return; end;
    Called["Basics"] = true; 

    Players = game:GetService("Players");
    ReplicatedStorage = game:GetService("ReplicatedStorage"); Replicated = ReplicatedStorage;
    TweenService = game:GetService("TweenService"); TS = TweenService;
    UserInputService = game:GetService("UserInputService"); UIS = UserInputService;
    RunService = game:GetService("RunService"); RSV = RunService; rsv = RunService;
    CoreGui = game:GetService("CoreGui");
    HttpService = game:GetService("HttpService");

    Client = Players.LocalPlayer; client = Client; LocalPlayer = Client; LP = Client;
    Camera = workspace.CurrentCamera; CC = Camera; cc = Camera;
    Mouse = LP:GetMouse(); mouse = Mouse;

    PlayerGui = LP:WaitForChild("PlayerGui");
    Backpack = LP:WaitForChild("Backpack");

    task.spawn(function()
        Character = LP.Character or LP.CharacterAdded:Wait(); Char = Character; char = Character;
        Humanoid = Char:WaitForChild("Humanoid"); Hum = Humanoid; hum = Humanoid;
        HumanoidRootPart = Char:WaitForChild("HumanoidRootPart") or Char.PrimaryPart; HRP = HumanoidRootPart; hrp =
            HumanoidRootPart;

        LP.CharacterAdded:Connect(function()
            Character = LP.Character; Char = Character; char = Character;
            Humanoid = Char:WaitForChild("Humanoid"); Hum = Humanoid; hum = Humanoid;
            HumanoidRootPart = Char:WaitForChild("HumanoidRootPart") or Char.PrimaryPart; HRP = HumanoidRootPart; hrp =
                HumanoidRootPart;
        end);
    end);
end;

Setup["ClientController"] = function(self)
    local Manager = {};
    if Called["ClientController"] then return Called["ClientController"]; end;
    Called["ClientController"] = Manager;

    self:Basics();

    function Manager:Reset()
        if replicatesignal then
            replicatesignal(Client.Kill);
        elseif Humanoid then
            Humanoid:ChangeState(Enum.HumanoidStateType.Dead);
        elseif Character then
            Character:BreakJoints();
        end;
    end;

    local Start, Last;
    function Manager:NoFall()
        task.spawn(function()
            Last = os.clock();
            if not Start then
                Start = os.clock();
                local NoFall = Instance.new("BodyVelocity");
                NoFall.MaxForce = vector.create(math.huge, math.huge, math.huge);
                NoFall.Velocity = vector.zero;
                NoFall.Parent = HRP;
    
                while Character and Character.Parent and os.clock()-Last<=1 do
                    task.wait();
                end;
    
                NoFall:Destroy();
                Start=nil;
            end;
        end);
    end;

    function Manager:Goto(cf)
        if typeof(cf) == 'Vector3' then cf = CFrame.new(cf) end;
        if typeof(cf) ~= 'CFrame' then return; end;

        if hrp then
            hrp.CFrame = cf;
        end;
    end;

    local Recorder = self:InputRecorder();
    local walkspeed, jumppower;
    Manager['Movement'] = {
        -- TP Walk
        TWX = nil,

        WS = function(Speed)
            walkspeed = Speed;
        end,

        TW = function(self, Toggle)
            if self.TWX then
                self.TWX:Disconnect();
            end;

            if Toggle then
                self.TWX = rsv.RenderStepped:Connect(function()
                    if hum.MoveDirection.Magnitude > 0 then
                        walkspeed = walkspeed or 1;
                        char:TranslateBy(hum.MoveDirection * walkspeed)
                    end;
                end);
            end;
        end,

        -- Jump
        IJX = nil,
        IJX2 = nil,

        JP = function(Power)
            jumppower = Power;
        end,

        IJ = function(self, Toggle)
            if self.IJX then
                self.IJX:Disconnect();
                self.IJX2:Disconnect();
            end;

            if Toggle then
                local Pressing = false;

                local function jump()
                    local Power = jumppower or hum.JumpPower or 50;
                    hrp.Velocity = Vector3.new(hrp.Velocity.X, Power, hrp.Velocity.Z);
                end;

                local function on()
                    Pressing = true;

                    while Pressing do
                        jump();
                        task.wait(.1);
                    end;
                end;

                local function off()
                    Pressing = false;
                end;

                self.IJX = Recorder:Bind("Space", on);
                self.IJX = Recorder:Bind("Space", off, true);
            end;
        end,
    };

    return Manager;
end;

Setup["HttpService"] = function(self)
    local Manager = {};
    if Called["HttpService"] then return Called["HttpService"]; end;
    Called["HttpService"] = Manager;

    self:Basics();

    function Manager:Webhook(weblink, title, fields)
        if not weblink then return; end;
        local data = {
            ["embeds"] = {
                {
                    ["title"] = title or "",
                    ["type"] = "rich",
                    ["color"] = tonumber(0x8383AA),
                    ["fields"] = fields
                },
            },
        };

        local newdata = HttpService:JSONEncode(data)

        request = http_request or request or HttpPost or syn.request;
        request({ Url = weblink, Body = newdata, Method = "POST", Headers = { ["content-type"] = "application/json" } });
    end;

    return Manager;
end;

Setup["File"] = function(self)
    local Manager, Allowed = {};
    if Called["File"] then return Called["File"]; end;
    Called["File"] = Manager;

    self:Basics();


    if readfile and writefile and isfolder and isfile and makefolder and delfolder then
        Allowed = true;
    end;

    function Manager:Read(path)
        if not Allowed then return; end;
        if typeof(path) ~= "string" then return; end;
        local contents;

        if isfile(path) then
            contents = readfile(path);
        elseif isfolder(path) then
            if listfiles then
                contents = listfiles(path);
            end;
        end;

        return contents;
    end;

    function Manager:Write(path, contents)
        if not Allowed then return; end;
        if typeof(path) ~= 'string' then return; end;

        local contents = contents or "";

        writefile(path, tostring(contents));
    end;

    function Manager:CreateFolder(path)
        if not Allowed then return; end;
        if typeof(path) ~= 'string' then return; end;

        if not isfolder(path) then
            makefolder(path);
        end;
    end;

    function Manager:DeleteFolder(path)
        if not Allowed then return; end;
        if typeof(path) ~= 'string' then return; end;
        if isfolder(path) then
            delfolder(path);
        end;
    end;

    function Manager:Execute(path)
        if not Allowed then return; end;
        if typeof(path) ~= 'string' then return; end;

        if isfile(path) then
            if runfile then
                runfile(path);
            else
                loadstring(readfile(path));
            end
        end;
    end;

    return Manager;
end;

Setup["Tween"] = function(self)
    local Manager, Storage = {}, {};
    if Called["Tween"] then return Called["Tween"]; end;
    Called["Tween"] = Manager;

    local Controller = Setup:ClientController();
    self:Basics();

    function Manager:Create(Data)
        if not Data or not Data.Position then return end

        -- Always reuse active tween
        if Storage.Active then
            local Active = Storage.Active
            Active:ChangeSpeed(Data.Speed)

            -- Update the target position for moving mobs
            Active.Data.Position = Data.Position
            Active.Data.Continue = Data.Continue

            local isClose = Active.isClose();
            if Data.Extra then
                Data.Extra(isClose)
            end

            return isClose
        end

        local Temporary = nil
        local function Move(dt)
            local Active = Storage.Active;
            local Data = (Active and Active.Data) or Data;
            
            local Target = Data.Position
            local CF
            if typeof(Target) == "CFrame" then
                CF = Target
                Target = Target.Position
            else
                CF = CFrame.new(Target);
            end

            local Speed = Data.Speed or {24, 24}
            if typeof(Speed) ~= "table" then
                Speed = {Speed, Speed}
            end

            local Surf = Data.Surf

            local p1 = HRP.Position
            local p2 = Temporary or Target

            if p2.Y < p1.Y then
                Speed[2] = 9999999999;
            end;

            local baseX, baseY = Speed[1], Speed[2]
            local stepX = baseX * dt
            local stepY = baseY * dt

            local xDiff = Vector3.new(p2.X - p1.X, 0, p2.Z - p1.Z)
            local yDiff = Vector3.new(0, p2.Y - p1.Y, 0)

            local xDis = xDiff.Magnitude
            local yDis = math.abs(yDiff.Y)

            stepX = math.min(stepX, xDis)
            stepY = math.min(stepY, yDis)

            local xDir = xDis > 0 and xDiff.Unit or Vector3.zero
            local yDir = yDis > 0 and yDiff.Unit or Vector3.zero

            -- Arrival check
            if xDis <= math.max(stepX, 1) and yDis <= math.max(stepY, 1) then
                if p2 == Target then
                    HRP.CFrame = CF;
                    Controller:NoFall();

                    if Data.Extra then
                        Data.Extra(true)
                    end

                    if not Data.Continue and Storage.Active then
                        Storage.Active:Cancel()
                    end;

                    return;
                else
                    HRP.CFrame = CFrame.new(p2)
                    Temporary = nil
                end
            end

            -- Surf logic
            if Surf and xDis > stepX then
                local Params = RaycastParams.new()
                Params.FilterDescendantsInstances = {Character}
                Params.FilterType = Enum.RaycastFilterType.Blacklist
                Params.RespectCanCollide = true
                Params.IgnoreWater = true

                local rayOrigin = p1 - Vector3.new(0, HRP.Size.Y / 2, 0)
                local rayDir = xDir * math.max(stepX, 4)

                local Hit = workspace:Raycast(rayOrigin, rayDir, Params)

                if Hit then
                    local Part = Hit.Instance
                    local Top = Part.Position.Y + Part.Size.Y / 2
                    local diff = Top - p1.Y

                    if diff <= math.max(stepY, 1) then
                        HRP.CFrame = CFrame.new(p1.X, Top + 1, p1.Z)
                    else
                        Temporary = Vector3.new(Hit.Position.X, Top + 1, Hit.Position.Z) - xDir * 2
                    end
                else
                    local Under = workspace:Raycast(p1, Vector3.new(0, -100, 0), Params)
                    if Under then
                        HRP.CFrame = CFrame.new(Under.Position + Vector3.new(0, 1, 0))
                    end
                end
            end

            -- Recalculate after surf adjustments
            p1 = HRP.Position
            p2 = Temporary or Target

            xDiff = Vector3.new(p2.X - p1.X, 0, p2.Z - p1.Z)
            yDiff = Vector3.new(0, p2.Y - p1.Y, 0)

            xDis = xDiff.Magnitude
            yDis = math.abs(yDiff.Y)

            xDir = xDis > 0 and xDiff.Unit or Vector3.zero
            yDir = yDis > 0 and yDiff.Unit or Vector3.zero

            local Translation
            if Surf and xDis > math.max(stepX, 1) then
                Translation = xDir * math.min(stepX, xDis)
            else
                Translation =
                    xDir * math.min(stepX, xDis) +
                    yDir * math.min(stepY, yDis)
            end

            Controller:NoFall()
            HRP.CFrame += Translation
        end

        Storage.Active = {
            Connection = RSV.Heartbeat:Connect(Move),

            Cancel = function(self)
                if self.Connection then
                    self.Connection:Disconnect()
                end
                Storage.Active = nil
            end,

            ChangeSpeed = function(self, New)
                if not New then return end
                self.Data.Speed = typeof(New) == "table" and New or {New, New}
            end,

            isClose = function()
                local p = HRP.Position
                local t = Storage.Active.Data.Position
                t = typeof(t) == "CFrame" and t.Position or t
                local dx = Vector3.new(t.X - p.X, 0, t.Z - p.Z).Magnitude
                local dy = math.abs(t.Y - p.Y)
                return dx <= 0.5 and dy <= 0.5
            end,

            Data = Data
        }

        return Storage.Active.isClose()
    end

    function Manager:GetActive()
        return Storage["Active"];
    end;

    function Manager:Cancel()
        local Active = self:GetActive();
        if Active then 
            Active:Cancel();
        end;
    end;

    return Manager;
end;

Setup["VirtualInputManager"] = function(self)
    local Manager, VIM = {}, Instance.new("VirtualInputManager");
    if Called["VirtualInputManager"] then return Called["VirtualInputManager"]; end;
    Called["VirtualInputManager"] = Manager;

    function Manager:Press(Key)
        if typeof(Key) == 'string' then
            local EnumKey;

            pcall(function() EnumKey = Enum.KeyCode[Key] end);

            if not EnumKey then return; end;

            VIM:SendKeyEvent(true, EnumKey, false, game);
            task.wait()
            VIM:SendKeyEvent(false, EnumKey, false, game);
        end;
    end;

    function Manager:Click(mb)
        if typeof(MB) == 'number' then
            mb = math.clamp(mb, 0, 2);

            VIM:SendMouseButtonEvent(0, 0, mb, true, game);
            task.wait();
            VIM:SendMouseButtonEvent(0, 0, mb, false, game);
        end;
    end;

    function Manager:Hold(Key)
        if typeof(Key) == 'string' then
            local EnumKey;
            pcall(function() EnumKey = Enum.KeyCode[Key] end);
            if not EnumKey then return; end;

            VIM:SendKeyEvent(true, EnumKey, false, game);
        end;
    end;

    function Manager:Release(Key)
        if typeof(Key) == 'string' then
            local EnumKey;
            pcall(function() EnumKey = Enum.KeyCode[Key] end);
            if not EnumKey then return; end;

            VIM:SendKeyEvent(false, EnumKey, false, game);
        end;
    end;

    function Manager:Move(x, y)
        if (not x) or (not y) then return; end;
        VIM:SendMouseMoveEvent(x, y, game)
    end;

    return Manager;
end;

Setup["InputRecorder"] = function(self)
    local Manager = {};
    if Called["InputRecorder"] then return Called["InputRecorder"]; end;
    Called["InputRecorder"] = Manager;

    self:Basics();

    Manager.Pressed = {};
    function Manager:Record(OnUP, Settings)
        if not Settings then return; end;
        local Callback = Settings['Callback'];
        local Valid = Settings['Inputs'];
        local Type = Settings['Type'];
        local Break = Settings['Break'];
        local CancelKeys = Settings['CancelKeys'] or { "Escape", "Backspace" };
        local IgnoreProc = Settings['IgnoreProc'];
        local Recorder;

        if not Callback then return; end;

        local function OnResponse(Input, isTyping)
            if (not Input) or (isTyping and not IgnoreProc) then return; end;

            local Keycode = Input['KeyCode'];
            local UserInputType = Input['UserInputType'];
            if not Keycode then return; end;
            local KeyName = Keycode.Name;

            if KeyName == "Unknown" then
                if Type == "KeyCode" then return; end;

                KeyName = UserInputType.Name;
            end;

            if table.find(CancelKeys, KeyName) then
                if Recorder then
                    Recorder:Disconnect();
                    Callback();
                    return;
                end;
            end;

            if Valid then
                if table.find(Valid, KeyName) then
                    Callback(KeyName);
                else
                    for i, v in next, (Valid) do
                        if string.lower(v) == string.lower(KeyName) then
                            Callback(KeyName);
                        end;
                    end;
                end;
            else
                Callback(KeyName);
            end;

            if Break and Recorder then
                Recorder:Disconnect();
            end;
        end;

        if OnUP then
            Recorder = UserInputService.InputEnded:Connect(OnResponse);
        else
            Recorder = UserInputService.InputBegan:Connect(OnResponse);
        end;

        return Recorder;
    end;

    function Manager:Bind(Key, Callback, OnUP, IgnoreProc)
        if (not Key) or (not Callback) then return; end;

        return Manager:Record(OnUP, {
            Inputs = (typeof(Key) == "table" and Key) or { Key },
            CancelKeys = {},
            IgnoreProc = IgnoreProc,

            Callback = Callback,
        });
    end;

    UserInputService.InputBegan:Connect(function(Input, proc)
        if not proc then
            local Keycode = Input['KeyCode'];
            local UserInputType = Input['UserInputType'];
            if not Keycode then return; end;
            local KeyName = Keycode.Name;

            if KeyName == "Unknown" then
                if Type == "KeyCode" then return; end;

                KeyName = UserInputType.Name;
            end;
        end;
    end);

    UserInputService.InputEnded:Connect(function(Input, proc)
        if not proc then
            local Keycode = Input['KeyCode'];
            local UserInputType = Input['UserInputType'];
            if not Keycode then return; end;
            local KeyName = Keycode.Name;

            if KeyName == "Unknown" then
                if Type == "KeyCode" then return; end;

                KeyName = UserInputType.Name;
            end;
        end;
    end);

    return Manager;
end;

return Setup;
